4.1 Prevent and troubleshoot runtime issues
==============================================================================================================================

Troubleshooting performance, security and errors
	Information:
	- Profiling is the process of analyzing a running computer program.
	- The Performance Wizard provides several different profiling methods:
		* CPU sampling:				Happens a few CPU cycles. Is more like an initial check.
		* Instumentation:			Adds code to the assembly to check for example the timing of every method.
		* .NET memory allocation:	Gives you insight into the memory management of your application by analyzing every object from creation to GB.
		* Resource contention data:	Provides information on how threads interact with each other and with the system, CPU utilization, overlapped input/output and more.
	- The Visual Studio Profiler performs a complete trace of the calls that occur in an application.
	- The Performance Monitor has a few monitors that are either system performance counters or application performance counters.


Troubleshooting security issues
	Information:
	- Check which part of the users is problemenatic and start there.
	

Implementing tracing, logging and debugging
	Information:
	- The process of saving the information is called logging.
	- Tracing is a technique that enables you to analyze your application while it's running.
	- Debugging is the process of analyzing results from various tools.
	- For tracing, you will first need to create one or more "System.Diagnostics.TraceListeners" which receive the tracing information and perform action on them.
	- Be consistent with logging.
	- For error logging, do one of the following things:
		* Use the HandleErrorAttribute
		* Override the controllers OnException method
		* Use a custom error filter.
	
	Code:
	- 	<configuration>
			<system.diagnostics>
				<trace autoflush="false" indentsize="4">
					<listeners>
						<add name="myListener" type="System.Diagnostics.TextWriterTraceListener" initializeData="TracingInfo.log" />               
						<remove name="Default" />
					</listeners>
				</trace>
			</system.diagnostics>
		</configuration>
			* Adds a TraceListener to the Web.Config file.
	- 	Trace.WriteLine("Message")
			* Using trace messages.
	- 	[HandleError(ExceptionType=typeof(System.IOException), View="FileError")]
			* All IOExceptions are send to the FileError view.


Enforcing conditions by using code contracts (needs to be installed before use)
	Information:
	- Code contracts enable a developer to publish various conditions that are necessary within an application:
		* Preconditions:	Conditions that have to be fulfilled before a method can execute.
		* Invariants:		Conditions that do not change during the execution of a method.
		* Postconditions:	Conditions that are verified upon completion of the method.
	

	Code:
	-	System.Diagnostics.Contracts.Contract.Requires(id > 0);
			* Using a precondition contract.
	-	System.Diagnostics.Contracts.Contract.Ensures(Contract.Results<Article>() != null);
			* Using a postcondition contract.
	-	[ContractInvariantMethod]
			* Attribute for using invariant checks on a class.


Enabling and configuring health monitoring
	Information:
	- Health monitoring is a subsystem built into ASP.NET that is specifically designed to handle logging of various web events such as:
		* Application lifetime events:	Raised when an application starts and stops, at process start and end times, for heartbeats and during regularly scheduled checks.
		* Security events:				Raised when a login attempt fails or an unauthorized attempt is made to access a secured URL.
		* Application errors:			Raised on errors and unhandled exceptions.
	- The benefits of health monitoring are:
		* It is part of the .NET framework so it can access a lot of events.
		* It follows the Microsoft provider framework, so it can be added through configuration. This enables you to change it easily when switching environments.
		* Ships with multiple log sources.
	- Ships with a Web.config template for easy implementation (see page 230 and 231 for the complete package).
	
	Code:
	-	<bufferModes>
			<add name="Logging" maxBufferSize="1000" maxFlushSize="200" urgentFlushThreshold="800" 
			regularFlushInterval="00:30:00" urgentFlushInterval="00:05:00" maxBufferThreads="1" />    
		</bufferModes>
			* Defines how long events are buffered before they are written to the provider.
	- 	<providers>
			<add name="EventLogProvider" type="System.Web.Management.EventLogWebEventProvider, System.Web" />
		</providers>
			* Indicates the provider to be used to write the event.
	- 	<profiles>
			<add name="Default" minInstances="1" maxLimit="Infinite" minInterval="00:01:00" custom="" />
		</profiles>
			* Set of profiles to use when configuring events.
	- 	<rules>
			<add name="All Errors Default" eventName="All Events" provider="EventLogProvider" 
			profile="Default" minInstances="1" maxLimit="Infinite" minInterval="00:01:00" custom="" />
		</rules>
			* Sets the relationship between the provider and the event so that the appropriate provider is called for an event.
	- 	<eventMappings>
			<add name="All Events" type="System.Web.Management.WebBaseEvent,System.Web" startEventCode="0" endEventCode="2147483647" />
		</eventMappings>
			* Shows that the application is mapped to log all events, heartbeats and application lifetime events.
	








4.2 Design an exception handling strategy
==============================================================================================================================

Handling exceptions across multiple layers
	Information:
	- Moral of the story: don't let errors get out of your layer.


Displaying custom error pages, creating your own HTTPHandler and setting Web.config attributes
	Information:
	- The "Global.asax" file contains some methods that can be used for exception handling:
		* Application_Start:	The startup method for applications.
		* Application_Error:	A global error handler (see page 237 for an example).
	- You can also use the Web.config file to add the <customErrors> section for handling exceptions.
	
	Code:
	- 	<customErrors mode="RemoteOnly" defaultRedirect="ErrorManager/ServerError">
			<error statusCode="400" redirect="ErrorManager/Status400" />
			<error statusCode="404" redirect="ErrorManager/Status404" />
		</customErrors>
			* Custom error section in the Web.config file. This has two important attributes:
				+ mode: Has the values "On" and "Of" for specifying if the custom errors should be used. The value "RemoteOnly" shows custom errors to remote users and not to local ones.
				+ defaultRedirect: Is the default redirect when the error is none of the specified ones.
	- 	<system.webServer>
			<httpErrors errorMode=”Detailed” />
		</system.webServer>
			* To make use of the custom errors, this has to be specified.


Handling first chance exceptions
	Information:
	- First chance exceptions are exceptions beofre they have been handled by an error handler. 
	- Enable "Common Language Runtime Exceptions" when searching for first chance exceptions.

	Code:
	- 	protected void CurrentDomain_FirstChanceException(object sender, System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs e){    
			if (e.Exception is NotImplementedException) {        
				// do something special when the functionality is not implemented    
			}
		}
			* Create an event method to catch first chance exceptions and log them.
	-	AppDomain.CurrentDomain.FirstChanceException += CurrentDomain_FirstChanceException;
			* Adds an event to the Global.asax file.









4.3 Test a web application
==============================================================================================================================

Creating and running unit tests
	Information:
	- Integration tests are designed to test dependencies to ensure that integration points are working properly.
	- Shims are small pieces of code that intercepts a call to an assembly and has it return an object you created or mocked.
	- Stubs are code that replaces working classses with a limited subset of a class you mocked up.
	- Shims are used for mocking assemblies outside your solution and stubs are used for creating mocks of classes within your solution.
	- In visual studio, you can select "Add Fakes Assembly" to create one.
	- Add *.Fakes.Shim* for shimming objects and *.Fakes.Stub* for stubbing objects.

	Code:
	- 	using (ShimsContext.Create())
		{
			// insert the delegate that returns call for DateTime.Now    
			System.Fakes.ShimDateTime.NowGet = () => new DateTime(2010, 1, 1);    
			MethodThatUsesDateTimeNow();
		}
			* Using shims. If you do not use the "using" statement, then every DateTime.Now will return the 1/1/2010 date.
	-	ICalculator calculator = new Calculator.Fakes.StubICalculator()     
		{       
			// Define each method:       
			Add = (a,b) => { return 25; }    
		};
			* Using stubs. 


Creating and running web tests
	Information:
	- There are three different approaches you can take when running load tests:
		* Constant:		Apply a constant load of users to your application.
		* Step:			Consider the following four values when using this approache:
							+ Initial user count:	The number of users that start as soon as the testing process starts.
							+ Maximum user count: 	The maximum number of users to be used in the process.
							+ Step duration:		The value, in seconds, of the time between the start of each new group of users.
							+ Step user count:		The number of users to be added after the expiration of each duration.
		* Goal-based:	Instead of specifying the total amount of users, you set how much percent of cpu (75%) the application should use.
	- Four primary types of test approaches:
		* Smoke:				Generally puts a light load on the application over a shorter period of time.
		* Stress:				Runs the application under a heavy load for several hours.
		* Performance:			Test responsiveness of your application. Keeps careful records of when requests started, when the first piece of data is returned to the client and the length of time and amount of data that was transferred.
		* Capactity planning:	Uses a testing process to support the correctness of the application and to help plan for deployment. Most of the time is this a combined Step and Goal based approach.









4.4 Debug a Windows Azure application
==============================================================================================================================

Collecting diagnostic information
	Information:
	- Because Windows Azure roles are destroyed when te application stops and re-created during the startup process, your logs will be gone. You should use the customized diagnostic feature for saving logs outside of the environment.
	- Using the "Microsoft.WindowsAzure.Diagnostics" namespace (contains the Windows Azure Software Development Kit (SDK)), you can add code to the ServiceDefinition.csdef file to allow diagnostics to be run.
	- You also need to add configuration code to the ServiceConfiguration(.Cloud or .Local depending on the environment).cscfg file.
	- The following diagnostics are captured by default:
		* Windows Azure logs
		* IIS logs
		* Windows Azure diagnostics infrastructure logs
	- The following diagnostics can be configured to use:
		* IIS Failed Request logs
		* Windows event logs
		* Performance counters
		* Crash dumps
		* Custom error logs
	- Each custom diagnostic tool needs it's own entry in the Diagnostics.wadcfg file (see page 258).
	- There are two ways to transfer logging information:
		* On-demand:	You saying when to transfer by coding in the application, within your role or an external application request.
		* Scheduled:	Set up during the configuration of the log directory.

	Code:
	-	<ServiceDefinition name="WindowsAzure1" xmlns=http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceDefinition schemaVersion="2013-03.2.0">    
			<WebRole name="WebRole1">        
				<!-- Other configuration information here ->        
				<Imports>          
					<Import moduleName="Diagnostics" />        
				</Imports>    
			</WebRole>
		</ServiceDefinition>
			* A small example of adding diagnostics to the ServiceDefinition.csdef file.
	- 	<ServiceConfiguration serviceName="WindowsAzure2 xmlns="http://schemas.microsoft.com/ServiceHosting/2008/10/ServiceConfiguration" osFamily="3" osVersion="*" schemaVersion="2013-03.2.0">    
			<Role name="WebRolePrimary">       
				<Instances count="1" />       
				<ConfigurationSettings>         
					<Setting name="Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString" value="UseDevelopmentStorage=true" />         
					<!—- this version is for deployment on the azure server             
					<Setting name="Microsoft.WindowsAzure.Plugins.Diagnostics.ConnectionString" value="DefaultEndpointsProtocol=https;AccountName=demoapp;AccountKey=[your key]" /> -->     
				</ConfigurationSettings>    
			</Role>
		</ServiceConfiguration>
			* Another small example of configuration code in the ServiceConfiguration.cscfg.


Choosing log types
	Information:
	- Don't log all, just capture what you think you'll need.


Debugging a Windows Azure application
	Information:
	- There are emulators available to test run the application on the exact same settings as Windows Azure.
	- Two ways to fix issues when deployed:
		* IntelliTrace:	
			+ If enabled, you can view the debugging information for an ASP.NET MVC application that's running through Windows Azure. 
			+ This can also be ran through the local environment.
			+ Enabling this feature is checking a checkbox just before deployment.
			+ Capturing only events has minimal impact on application performance, but capturing the call information along with events can affect the performance of your application.
			+ Transfer the logs by opening the "Windows Azure Compute" node that is available in Sever Explorer within Visual Studio.
		* (Remote Desktop Protocol) RDP:
			+ Need to authorize this when first using it.
			+ Access the server by opening the "Windows Azure Compute" node and select the "Connect Using Remote Desktop". 
			+ There  you can review IIS logs, Windows event logs and perform other tasks as needed.



























