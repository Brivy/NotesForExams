1.1 Plan the application layers
==============================================================================================================================

Planning data access
	Information:
	- When using data access you have two options:
		* O/RM (object relational mapper): hydrates the object with the data from the database
		* Writing own components: Can be used when working not so close with your model or using NoSQL
	- Three ways of designing with Entity Framework:
		* Model first: Create your model in Visual Studio
		* Code first: Create POCO (plain old CLR object) classes
		* Database first: Create a datbase and tables
	- The repository pattern is intended to create an abstraction layer between the data access layer and the business logic layer.
	
	
Planning for separation of concert (SoC)
	Information:
	- SoC is a software development concept that sparates a computer program into different sections, or concerns, in which each concern has a different purpose (for example N-tier development)
	- While using MVC, you need to consider two parts of the UI:
		* The part of the UI rendered on the server
		* The part of the javascript code on the client side.
	- Loose coupling is an architectural approach in which the disigner seeks to limit the amount of interdependencies between various parts of a system.


Using models, views, and controllers appropriately
	Information:
	- The three components in MVC:
	- "The model" is the part of the application that handles business logic.
		* A convention-based aspect of this is the placement (most of the time in the Models folder).
		* Controllers typically instantiate the model and provide it to the view for display.
		* Building a model can be done in different ways:
			+ Domain model: When working in the middle tier of the application (by using the entity framework)
			+ View model: Is generally the result of aggregating multiple classes into a single object
			+ Input model: When data is being uploaded to the server from the client with each individual HTTP request (caputure user input).
		* Using model binders for a simple way of posting form data to an action method as paramater. 
		* The default model binder (DefaultModelBinder using IModelBinder) contains an GetValue method that retrieves the value of a specified parameter or type. 
		* It's possible to create custom model binders for example when using DI and IoC.
	- "The controller" is logic for handeling incoming requests, user input and interaction and executes application logic. 
		* Based on the ControllerBase class and is responsible for: 
			+ Locating the appropriate action method to call.
			+ Validating that action method can be called.
			+ Getting values in the model to use as parameters.
			+ Managing all errors and calling the view engine to write the page.
		* Action methods are typically one-to-one mappings to user interactions.
		* ActionResults is any kind of outcome from an action. It can for example return:
			+ A view.
			+ A partial view.
			+ JSON.
			+ Binary data.
			+ Redirect to another action.
			+ Etc.
		* For routes, the default MvcHandler will be used. This will extract the controller information by comparing the request with the template values in the routing table. 
		* The default handler extract the string and sends it to a controller factory that returns the appropriate controller.
		* Both the handler (IHttpHandler) and the controller factory (IControllerFactory) can be custom made by using their interfaces.
		* By using attributes, you can provide extra information to the framework:
			+ ActionName, AcceptVerbs and NonAction help the framework to  determine which action to run.
			+ OutputCache, ValidateInput and HandleError can be used to add for example caching, validation and error handling.
			+ Custom actions can be made by overriding the ActionFilter class.
		* Create async actions to increase performance:
			+ Create an action that runs synchronously but uses asynchronous work.
			+ Create an async partial view that will run your work in a different thread.
			+ Using AJAX to load in a page async.
	- "The view" is part of the application responsible for displaying information to users.
		* Using the ViewDataDictionary (which is wrapped by a ViewBag), you can display a set of messages to the user.
		* There are multiple kinds of views:
			+ Strongly-typed: No need for casting because you set the attached model explicitly.
			+ View-specific: Defining and using a view model instead of a model directly.
			+ Partials: A view that can be defined within a view. Doesn't contain <html> and <head> tags.
			+ Master or layout: A way to share a design across multiple pages.
			+ Scaffold template: A template that creates standard pages as part of the process when creating a project.
		* Web forms is old and the syntax isn't used by the razor syntax.
		* Webforms uses:
			+ Code expression: <%: article.Title %>
			+ Code blocks that create a variable: <% ... %>
			+ Incorporating plain text into code blocks: <% if (...) { %> ... <% } %>
			+ Generic method: <%: %>
		* Razor uses:
			+ Code expression: @article.Title
			+ Code blocks that create a variable: @{ ... }
			+ Incorporating plain text into code blocks: @if (...) { ... }
			+ Generic method: @()
		* Both engines are derived from the BuildManagerViewEngine, which is derived from the VirtualPathProviderViewEngine (again, to implement your own engine, you can override them).
		* You can create HTML helper classes to create HTML programmatically. 


Choosing between client-side and server-side processing
	Information:
	- When considering remember that there is always latency when connecting over the internet.
	
	
Designing for scalability
	Information:
	- There are two ways in which an application can scale: "Horizontally" or "Vertically".
	- Horizontally scaling is adding additional nodes to the system (web farm):
		* Consider where session state information, if you should use caching, where to store files, etc.
		* Is certainly the cheapest way.
	- Vertical scaling is adding resources to a single system.
		* Can be done by increasing the CPU or memory. 
		* The application should pay more attention to threading, input/output, garbage collection and other decisions that would help the application take better advantage of the additional memory or CPUs.
		* Is limited by how much you can add.
		* Single point of failure.
	- Be aware of the database scalability options like adding a different database with different credentials.
		








1.2 Design a distributed application
==============================================================================================================================

Integrating web services
	Information:
	- When using a MVC project, you can inherit the class ApiController for web services. This controller does not use views, but searches for the "Accept" header to determine how to send the data back.
	- ApiController handles the serialization and deserialization for you. When using a regular controller, you will have to do this on your own.
	- ASP.NET Web Services (ASMX) is an old (SOAP)-based web service.
	- You can consume a web service easily by using the "Add a Service Reference" command. This approach expects the presence of a Web Service Description Language (WSDL) at the service you are calling.
	- The WSDL serves as an endpoint, it includes the network protocol, message type and message format.
	- The farther the pieces of your application are from each other, the more variables that have to be accounted for like:
		* latency.
		* firewalls.
		* protocol limitations.
	
	Code:
	- using (ServiceProxy proxy = new ServiceProxy()) { ... }
		* Use a generated web service proxy.
	- NetworkCredential credential = new NetworkCredential("username", "password");
		* Create network credentials for a HttpService.
	- XDocument xml = _httpService.Get(host, path, parameters, credentials);
		* Get a xml document from the httpservice.
	
	
Designing a hybrid application
	Information:
	- A hybrid application is an application hosted in multiple places.
	- There are two primary hybrid patterns:
		* Client-centric pattern: The client application determines where the application needs to make its service calls
		* System-centric pattern: This includes a service bus (like Windows AppFabric) that will distribute the service requests for you
	- When working on-premise, you have low latency and good connection options. This is not guaranteed by using a hybrid application. Other things to mention:
		* Authorization and access are complicated because of multiple domains
		* Consistency and concurrency are complicated because of multiple domains
	
	
Planning for session management in a distributed environment
	Information:
	- A session is stored on the server and is unique for a user's set of transactions. The browser needs to pass back a unique identifier, called SessionId, which can be sent as part of a small cookie or added onto the query string where it can be accessed by the default handler.
	- While ASP.NET MVC lies on top of ASP.NET, you can access session information and use it. However, ASP.NET MVC is designed to run in a stateless manner.
	- If working sessionless in a distributed environment (because session management can be difficult), you can use one of the three modes in IIS:
		* InProc (default): Web sessions are stored in the web server's local memory. Best for performance but is not clusterable.
		* StateServer/OutProc: Session information stored in memory on seperate server. You'll need to have a connection string for that.
		* SQLServer: Same advantage as StateServer, but will add some latency to the session access.
		
		
Planning web farms
	Information:
	- Web farms are groups of servers that share the load of handling web requests.
	- Because SoC (Seperation of Concern) is inherent in the MVC architecture, you can locate components of the application on different servers.
	- Some advantages of having a web farm with a load balancer:
		* High availability: if a server goes down, the load balancer will redirect the request to working servers.
		* Decrease contention problemens: Increased performance by reducing load on each server.
		* Scalability ofcourse.
	- Be carefull when trying to access the default session. The load balancer cannot ensure to match a particular server to a session (known as a "sticky session").
	- Use the IIS setting StateServer or SQLServer for using sessions in web farms.
	
	
	
	
	
	
	


1.3 Design and implement the Windows Azure role life cycle
==============================================================================================================================

Understanding Windows Azure and roles
	Information: 
	- Windows Azure provides both platform as a service (PaaS) and infrastructure as a service (IaaS) services, and is classified as the "public cloud" in Microsoft's cloud computing strategy.
	- With PaaS, cloud providers deliver a computing platform, typically including an operating system, a programming language environment, a database, and a web server.
	- IaaS offers virtual machines.
	- Azure provides three different types of solutions:
		* Virtual Machines: Basically online VM's. 
		* Web Sites: Web hosting for your applications that are scalable.
		* Cloud Services: A PaaS approach.
		
		
Identifying startup tasks
	Information:
	- Windows Azure startup tasks are used to perform actions before a role starts. There are three types of roles:
		* Web: Used to run IIS in Azure.
		* Worker: Used for a middle-tier application without IIS.
		* VM: Beyond the scope of Web and Worker. This role cannot manage startup tasks.
	- Startup tasks are for example registering COM components, installing a component or set registry keys.
	- Startup tasks run each time a role recycles in addition to when a server reboots.
	- Startup tasks can for example be used when you need to assure that a secondary application is running while your application is running.
	- The procedure followed by Windows Azure when a role starts is the following:
		* The instance is marked as Starting. It will no longer receive traffic.
		* Startup tasks are executed according to their taskType attribute:
			+ Simple tasks are executed synchronously.
			+ Background and foreground tasks are started asynchronously. This is in parallel with the startup task.
		* The role host process is started and the site is created in IIS.
		* The task calls the Microsoft.WindowsAzure.ServiceRuntime.RoleEntryPoint.OnStart method.
		* The instance is marked as Ready and traffic is routed to the instance.
		* The task calls the Microsoft.WindowsAzure.ServiceRuntime.RoleEntryPoint.Run method.
	- The AppCmd.exe command-line tool is used to manage IIS settings at startup. The tool enables you to add, modify or remove settings from both web applications and websites.
	- Misconfiguring AppCmd.exe can result in runtime errors, what can stop the task from starting up.
	- Setting a task in the background prevents Azure from waiting until the task completes before it puts the role into a Ready state and creates the website.
	- The names of websites are typically named "rolename_roleinstance number" while the application pools are usually named with a GUID.
	- Objects within AppCmd are as followed:
		* Site: Virtual site administration
		* App: Application administration
		* VDir: Virtual directories administration
		* Apppool: Application pools administration
		* Config: General configuration sections administration
		* Backup: Management of server configuration backups
		* WP: Worker process administration
		* Request: Active HTTP request display
		* Module: Server module administration
		* Trace: Server trace log management
	- You can add configuration information in the Windows registery instead of configuration files. This keeps the information secure. 
	- It's possible to manage the registery by a small application or script that can be ran by a startup task. 
	
	Code:
	-	<Startup>
			<Task commandLine="Startup\ExecWithRetries.exe &quot;/c:Startup\AzureEnableWarmup.cmd&quot;
			/d:5000 /r:20 /rd:5000 &gt;&gt; c:\enablewarmup.cmd.log 2&gt;&gt;&amp;1"          
			executionContext="elevated" taskType="background" />
		</Startup>
		* Sets a specific task as a background task.
	- %windir%\system32\inetsrv\appcmd list sites "/name:$=MyWebRoleName*" /xml | %windir%\system32\inetsrv\appcmd set site /in /serverAutoStart:true
		* Use the search functionality to search for web role name and then use it as a prefix for the name of the site. You can pipe this output to AppCmd.exe to manage the configuration.
		
		
Identifying and implementing Start, Run and Stop events
	Information:
	- There are many conceptual similarities between the OnStart method and a startup task:
		* They both have the same time-out. If you are not out of either function, the execution of role startup continues.
		* They both are executed again if the role is recycled.
		* You can configure both to process ahead of the role.
	- Differences are:
		* Startup tasks are ran in a different process, which enables it to be at a different level of privilege than the primary point of entry.
		* State can be shared between the OnStart method and the Run method because they both are in the same application domain (AppDomain).
		* A startup task can be configured to be either a background or foreground task that runs parallel with the role.
	- When the configured startup tasks are completed, Azure role begins the process of running. You can override the following functions:
		* OnStart: Can be used to manage initialization needed to support your role. Will set Azure rol to Busy. If "true" is returned, Azure continues.
		* Run: Equivalent to the Main method in an actual application. When returning within this method, the application will be stopped and the OnStop method will be called for cleanup.
		* OnStop: Called when the role instance is stopped. You will have 5 minutes before Azure will terminate the code.
		
	Code:
	- public class WorkerRole : RoleEntryPoint
		* When inheriting this class, you can override OnStart, Run and OnStop methods.









1.4 Configure state management
==============================================================================================================================

Choosing a state management mechanism
	Information:
	- The first decision when regarding state should by if you would like to use it.
	- Web Forms uses ViewState, an ability to carry its state around the web application with it, storing information as needed.
	- State information can be stored at the following locations:
		* Cache: 			Memory pool stored on the server and shared across users.
		* Session: 			Stored on server and unique for each user.
		* Cookies: 			Stored on the client and passed with each HTTP request to the server.
		* QueryString: 		Passed as part of the complete URL string.
		* Context.Items: 	Is part of the HttpContext and lasts only the lifetime of that request.
		* Profile: 			Stored in database and maintains information across multiple sessions.
	- The cache is a key-value pair that should be accessible by any user or page in the application.
	- Every server in a webfarm should have its own copy of the cache.
	- Inheriting the SessionStateStoreProviderBase enables you to create your own session provider. If you run for example on an Oracle database, there is no built-in support for managing state that is shared by multiple servers.
	- When you want to use your own session state provider, enable this in IIS by selecting Custom.
	- Cookies are individualized by domain or subdomain, so with careful planning you can use cookies across a web farm.
	- Within MVC you can find them under HttpContext.Request.Cookies and return them under HttpContext.Response.Cookies.
	- The query string is not part of the route data and thus is ignored by the routing engine.
	- Within MVC you can access the data in the HttpContext.Request.QueryString["attributeName"] and parse it within javascript with window.location.href.
	- Context.Items is used to add information to the request through the use of an HTTP module in wich you can add some information to the request that will be available to the other modules and to the handler.
	- For example, you can store the result of an authentication module to use in other parts of the application.
	- Profile information is stored in the database by user name and can be accessed through HttpContext.Profile["miscellaneousData"].
	- The profile is part of the Membership and Roles provider, and you need to configure a provider in the Web.config file.
	- Just a friendly remainder that you can also use the state on the clients machine (like Local Storage) to prevent sending requests over and over.


Planning for scalability
	Information:
	- If all servers of a webfarm use the same state server or SQL Server, using OutProc session to access state information stored in a session should get consistent responses, regardless of the server calling the information and serving the page.
	- You can use a profile if the user is logged in to the system. Then you can use the HTTP Authorization header to get the information needed for state management.
	- When using web farms, make sure the identifier you send back and forward is identified on every server.


Using cookies or local storage to maintain state
	Information:
	- When you need to use multiple request, changes are high that you are in need of cookies.
	- No extra code is needed for cookies - they are a standard part of server/client communication.
	- Sessionstorage is available until you close the browser window. LocalStorage is beyond the browsers lifetime.

	Code:
	- if (window.localStorage) { window.localStorage.SetItem('key', 'value'); }
		* Check if the browser can use the localStorage.
	- window.AddEventListener('storage', displayStorageEvent, true);
		* Set a listener on the storages (local and session).


Applying configuration settings in the Web.config file
	Information:
	- Configuration can also be applied in a lower part of the configuration stack including the Machine.config file, which is the lowest configuration file in the stack and applies to all websites on that server.
	
	Code:
	- 	<system.web>
			<sessionState mode="InProc" cookieless="false" timeout="20"
			sqlConnectionString="data         
			source=127.0.0.1;Trusted_Connection=yes"        
			stateConnectionString="tcpip=127.0.0.1:42424"/>
		</system.web>
		* An example on how to configure an InProc state management.
	- 	<system.web>    
			<sessionState mode="StateServer" stateConnectionString="192.168.1.103:42424"/>
		</system.web>
		* An example on how to configure an StateServer.
	- 	<profile defaultprovider="DefaultProfileProvider"     
			inherit="MyApplication.Models.CustomProfile"/>
		* An example on how to use the ASP.NET Membership provider.


Implementing sessionless state
	Information:
	- If you want to go sessionless, you will an unique identifier from request to request. MVC offers a few ways of doing this:
		* Creating an identifier on the server the first time the user visits the site and continue to pass this information from request to request.
		* Use a hidden form field to store and pass the information from one request to the next.
		* Script and unique identifier storage on the razor layout or master page.
		* Add the unique identifier to the query string.
		* Add the unique identifier to the URL.
	
	
	
	
	
	
	


1.5 Design a caching strategy
==============================================================================================================================

Implement page output caching
	Information:
	- The browser itself can cache GET requests.
	- Donut caching is a server-side technology that caches an entire page other than the pieces of dynamic content - the donut holes.
	- Razor doesn't support Donut caching, but by using the Subtitution APIs through the HttpResponse.WriteSubtitution, you can create a MVC Helper for that.
	- Donut hole caching caches only selected portions of the page while keeping the rest of the page dynamic. 
	- Can be applied to either an controller and action methods (only works with GET requests) (see code example).
	- Distribution caching is the ability to create data on one application server and share it with the other servers on a webfarm.
	- Windows Server AppFabric in short:
		* You will have a cache client (MVC ASP.NET app) and a cluster of cache servers.
		* The cache client also has it's own local cache.
		* First it will check it's local cache, then it will ask the cluster and after that it will give the user new information.
		* Because it's windows stuff, the items can be any serialized .NET objects.
		* Synchronization between the cache servers is key (like the local time because objects will have timeouts).
		* Can encrypt the synchronization process.
		* Is just another OutProc session storage type.
	
	Code:
	- [OutputCache(Duration=120, VaryByParam="Name", Location="ServerAndClient")]
		* Attribute to add caching to an action:
			+ Duration: Caching duration
			+ VaryByParam: Stores a different version of the output based on a different parameter collection that was sent in for the action call.
			+ Location: Gives direction to where caching takes place. Using "NoStore" switches it off. Default is "Any" but other options are "Client", "Downstream", "Server" and "ServerAndClient".
	- [ChildActionOnly][OutputCache(Duration=60)]
		* Attributes to add donut hole caching to an action for a partial view. Call this action method with @Html.Action("ProductsChildAction") in the razor parent view.


Implementing data caching
	Information:
	- .NET 4 has a new Caching Framework. It uses ObjectCache and MemoryCache objects within the System.Runtime.Caching assembly.
	- It is recommended to create a CacheProvider class that implements the ICacheProvider interface and is placed between the business and the data access layer because it decreases the load on the database.


Implementing application caching
	Information:
	- For application caching, you must create the application cache manifest:
		* CACHE: Represents resources that should be cached on the client.
		* NETWORK: Represents resources that shouldn't be cached.
		* FALLBACK: Represents resources that should be returned if the corresponding resources are not found.
	- If you transfer the manifest, set the correct MIME-type to "text/cache-manifest".
	- The browser will fetch resource information in only three cases:
		* When the user clears the cache.
		* When there is any change in the manifest file.
		* When the cache is updated programmatically via JavaScript.

	Code:
	- CACHE MANIFEST
		CACHE:
		NETWORK:
		FALLBACK:
		* Bare-bones of a cache manifest.
	- <html manifest="site.manifest">
		* Reference the manifest.


Implement HTTP caching
	Information:
	- HTTP caching is a caching mechanism built into the HTTP protocol that handles its own version of expiration calculation and uses it to determine the response to send to the client.
	- HTTP must return the appropriate response when using the cache like:
		* 304 (Not Modified)
		* 305 (Proxy Redirect)
		* 4xx or 5xx (Errors)









1.6 Design and implement a WebSocket strategy
==============================================================================================================================

Reading and writing string and binary data
	Information:
	- HTTP polling is an ongoing conversation between a client and server in which the client appears to have a constant connection with the server based on series of standard AJAX requests.
	- HTTP long polling is a server-side technique in which the client makes an AJAX request to the server to retrieve data but it keeps the request open until it has data to return.
	- WebSockets acts as a replacement for HTTP in that it takes over the communication protocol between the client and the server for a particular connection.
	- Use WebSockets to support functionality that needs two-way, long-running communication without having to support the request-response process.
	- Check with "System.Web.HttpBrowserCapabilities" if the browser supports HTML5.
	- WebSockets generally involve three steps:
		* Establishing the connection between both sides with a hand shake.
		* Requesting that WebSocket server start to listen for communication.
		* Transferring data.
	- For .Net, you will need to accept and upgrade a HTTP GET request into a WebSockets connection. The information for this can be found under the namespace "System.Web.WebSockets".

	Code:
	- 	socket = new WebSocket("ws://localhost:1234/socket/handle");
		socket.addEventListener("open", function (evnt) { ... }, false);
		socket.addEventListener("message", function (evnt) { alert(evnt.data); }, false);
		socket.addEventListener("error", function (evnt) { ... }, false);
			* Using WebSockets in Jquery.
	- 	var socket = new WebSocket("ws://localhost:1234/socket/handle");
		socket.onopen = function() { ... }
		socket.onmessage = function() { ... }
		socket.onclose = function() { ... }
			* Using straight method calls
	- 	WebSocketReceiveResult socketResult = await context.WebSocket.ReceiveAsync(arraySegment, CancellationToken.None);            
		if (context.WebSocket.State == WebSocketState.Open)            
		{                    
			string message = Encoding.UTF8.GetString(arraySegment.Array, 0, socketResult.Count);                    
			userMessage = "Your message: " + message + " at " + DateTime.Now.ToString();                   
			arraySegment = new ArraySegment<byte>(Encoding.UTF8.GetBytes(message));                    
			await context.WebSocket.SendAsync(arraySegment, WebSocketMessageType.Text, true, CancellationToken.None);
		}
			* Using a websocket in ASP.NET.


Choosing a connection loss strategy
	Information:
	- This chapter comes done to explaining that you should handle errors when you lose a connection. 
	- Most of the the time, an onclose or an onerror event is thrown, but you should keep in mind that this doesn't have to be the case.


Deciding when to use WebSockets
	Information:
	- Use it to have minimal overhead.
	- Let the server check if the browser is HTML5 compatible:
		* Use the WebSocket for HTML5 connections.
		* Use a partial view with Jquery if not HTML5 supported.
	- Because of the minimal overhead, you will not send headers with the request. This can be dangerous when you look for the CONTENT-TYPE header.
	- It's hard to test if both ends support websockets because you will need to make a connection and send data.









1.7 Design HTTP modules and handlers (not needed in exams, learn the filter and middleware variant in dotnet core)
==============================================================================================================================

F.Y.I. This chapter is probably outdated because of ASP.NET Core. There you will use middleware to fix this stuff.

Implementing synchronous and asynchronous modules and handlers
	Information:
	- Modules are called before and after the handler executes. They are intended to enable a developer to interact, participate or modify each request.
	- While implementing IHttpModule, you'll need to implement the two methods "void Init(HttpApplication)" and "void Dispose()".
	- You'll need to configure the <httpModule> section in the Web.config file to use a module
	
	
Choosing between modules and handlers in IIS
	Information:
	- Http handlers help you inject preprocessing logic based on the extension of the file name requested.
	- Http modules are event-based and inject preprocessing logic before a resource is requested.

































