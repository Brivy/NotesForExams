5.1 Configure authentication
==============================================================================================================================

Authenticating users
	Information:
	- Authenticating a user is the process of ensuring his of her identity.
	- You can authenticate users by:
		* Microsoft Internet Information Services (IIS)
		* .NET application framework
	- The following methods can be used for authentication:
		* Challenge-based authentication occurs when the client must respond to the server's demand for credentials. Examples of this are:
			+ Basic
			+ Digest
			+ Windows
			+ Client Certificate Mapping
			+ IIS Client Certificate Mapping
		* Login redirection-based occurs when the client sends login credentials to the application without being required by the server. Examples of this are:
			+ Forms authentication
		* Anonymous authentication does not require any credentials from the user.
	- During the IIS request process, the HttpModule verifies the user information, adds this to the HttpContext and the "System.Threading.Thread.CurrentPrincipal".
	- Within the .NET authentication, you have two interfaces:
		* System.Security.Principal.IPrincipal:	Contains information about the user, including the user's roles.
		* System.Security.Principal.IIdentity:	Contains information about the users, such as whether they are authenticated and by their name.
	- The IPrincipal and IIdentity interfaces have multiple implementations:
		* WindowsIdentity and WindowsPrincipal: The implementations that works with Active Directory and other Windows user storages.
		* FormsIdentity and GenericPrincipal:	The implementations that support forms authentication.
		* GenericIdentity and GenericPrincipal:	Implementations that support the more flexible custom user.
	- If the authentication failed, the server will return an Unauthorized token.
	- Anonymous authentication is by default the only form of authentication that is installed and enabled in IIS 7 and above.
	- Basic authentication is a simple way to transmit a user name and password between a client and server. They are Base64 encoded but not encrypted.
	- Digest authentication uses a challenge-response mechanism to ensure that the user credentials required for authentication are not sent in clear text (without encryption):
		1. The server sends a challenge to the client in response to a request of a secured page.
		2. The client generates a unique challenge value.
		3. The client creates a hash of both the challenge and the challenge value.
		4. The client returns a challenge value and hash to the server.
		5. The server creates its own version of the hash to ensure that it matches the one from the client.
		6. The server creates a new hash of the challenge and challenge values.
		7. The server sends the new hash to the client.
		8. THe client calculates its own version of the hash to ensure that it matches the one from the server.
	- Forms authentication is a way to allow authentication and authorization without having to use the built-in Windows security system:
		1. Login screen with username and password.
		2. Send to the server that will try to match them to some form of data store.
		3. The Membership provider is called to ensure that the user's authentication token is set and that the user can remain logged in through the rest of the session.
		4. Using the "FormsAuthentication.SetAuthCookie" method makes the authentication token available for the rest of the session.
	- You can use Windows Authentication when your server runs on a corporate network using Active Directory domain identities or Windows accounts to identify users. Windows Authentication is best suited to intranet environments where users, client apps, and web servers belong to the same Windows domain.
	- There are two windows authentication protocols:
		* NTLM: Authentication protocol that runs on top of HTTP and is used for SSO (single sign on). 
		* Kerberos: Also an authentication protocol but better. If for any reason Kerberos fails, NTLM will be used instead.
	- Impersonation authentication is an add-in to Windows authentication that allows your ASP.NET MVC application to use the Windows identity provided by Windows authentication.
	- By enabling Impersonation authentication, you can access more data of an user like the network or file resources. This will be defined in the "System.Security.Principal" "WindowsIdentity" object.
	- For Client Certificate-based authentication, you'll need a SSL certificate installed on your server and every client also neds to have a certificate installed.
	- There are two versions of Client Certificate authentication:
		* Client Certificate-based: 					Both the IIS server and the client computer are members of an Active Directory domain. The users are also stored within this.
		* IIS Client Certificate-based authentication:	Maps a client certificate to an Active Directory domain or local server user store and is more flexible. 
	- Only use custom authentication when you can anwser the following questions:
		* Do standard universal providers fulfill my application's requirements?
		* Does the ability of Forms authentication to customize the login process provide needed flexibility?
		* Can I support all the requirements of implementing IIdentity and IPrincipal?
		* Do I have to re-create the entire process from the base up to satisfy the requirements.
	
	Code:
	-	System.Threading.Thread.CurrentPrincipal = System.Web.HttpContext.Current.User;
			* Set the current user on the thread so you can access it from outside of the immediate web application.
	-	appcmd set config -section:anonymousAuthentication -enabled:true
			* Enable anonymous authentication.
	-	appcmd set config -section:basicAuthentication -enabled:true
			* Enable basic authentication.
	-	FormsAuthentication.SetAuthCookie(uname, false);
			* Set a forms auth cookie.
	- 	FormsAuthentication.ClearAuthCookie();
			* Clear the forms auth cookie.
	- 	<configuration>  
			<system.web>    
				<identity impersonate="true" />  
			</system.web>
		</configuration>
			* Enable Impersonation authentication in the Web.Config.


Enforcing authentication settings
	Information:
	- The easiest way to apply authentication settings is by using the [Authorize] and [AllowAnonymous] attributes on actions and controllers.
	- Using a blocked list, you can specify what actions are allowed and all other actions are not allowed.
	- Using a blocked list, you can specify what actions are not allowed and all other actions are allowed.
	- To keep the generated token of the Forms authentication secure, use HTTPS.

	Code:
	-	Thread.CurrentPrincipal.Identity.IsAuthenticated
			* Checks the current user on the thread if it is authenticated.
	- 	HttpContext.Current.User.Identity.IsAuthenticated
			* Checks the current user in the HttpContext if it is authenticated.
	-	public static void RegisterGlobalFilters(GlobalFilterCollection filters) {    
			filters.Add(new AuthorizeAttribute());
			filters.Add(new RequireHttpsAttribute()); 
		}
			* Apply global authentication to the application and HTTPS.


Choosing between Windows, Forms and custom authentication
	Information:
	- Windows authentication is the default one and has six types of authentication methods (see above).
	- Forms is flexible but requires somewhat more work. 
	- Custom is more flexible than forms but also requires a lot more work.


Managing user session by using cookies
	Information:
	- To retain user login state, Forms authentication uses a cookie to manage the Forms authentication ticket, which is an encrypted version of the authenticated user name stored in the Forms authentication cookie.
	- The Forms cookie is passed which each and every request.
	- While casting the "UserIdentity" property from the principal (stored in the "HttpContext" or the thread) to a "FormIdentity", you can access the "Ticket" property containg the user information.
	- Alternatively, you can store the session state, which contains user information on the server to maintain authentication state rather that storing user information in a ticket.
	- The "FormsAuthenticationToken" is a great place to store authentication data, but the information is always passed as part ot the request/response process what can impact performance.
	- Consider the above tradeoffs between storing in a cookie and maintaining it on a server.

	Code:
	- 	FormsAuthenticationTicket authTicket = new FormsAuthenticationTicket(
			1, 
			userName, 
			DateTime.Now, 
			DateTime.Now.AddDays(90),                
			createPersistentCookie, // a Boolean indicating whether a cookie should be created on the user's machine                
			String.Join(";",rolesArr) //user's roles 
		);
			* The creation of a Forms authentication cookie.
	- 	string encTicket = FormsAuthentication.Encrypt(authTicket); 
			* Encrypt the Forms cookie.


Configuring membership providers
	Information:
	- The classic provider model is based on information in the configuration files.
	- With newer versions like OAuth and OpenID, the user doesn't have a password.
	- The term "SimpleMembership" is an umbrella term for both "SimpleMembership" and "SimpleRoles":
		* SimpleMembership: 	Has methods are implemented as providers that implement core ASP.NET APIs.
		* SimpleRoleProvider:	Impelemnts "RoleProvider" abstract base class.
	- The default membership providers provide the ability to store key-value pair information in a special database table. 
	- For this to work, you must initialize the "WebSecurity" class in a startup routine by running the InitializeDatabaseConnection method.
	- WebSecurity is a wrapper for SimpleMembership and contains the Login, ResetPassword, CreateAccount and ChangePassword methods.
	- There is only one "SimpleMembershipProvider" but you can write your own if necessary.
	- In the membership configuration, you can add multiple providers.
	
	Code:
	- 	<system.web>    
			<membership>        
				<providers>            
					<clear/>            
					<add ... />       
				</providers>    
			</membership>
		</system.web>
			* Configuring an ASP.NET membership provider to use the SqlMembershipProvider.
	-	WebSecurity.InitializeDatabaseConnection(string connectionString, string providerName,string userTableName, string userIdColumn, string userNameColumn, bool autoCreateTables)
			* Initializes a database connection for the WebSecurity class.
	-	<connectionStrings>    
			<add name="DefaultConnection" connectionString="ConnectionStringHere" providerName="System.Data.SqlClient" />
		</connectionStrings>
		<appSettings>    
			<add key="TableName" value="CustomLoginTable"/>    
			<add key="IdColumn" value="Id"/>    
			<add key="UsernameColumn" value="Username"/>
		</appSettings>
			* Using membership provision.


Creating custom membership providers
	Information:
	- If you need a different way to manage membership, change the underlying ASP.NET membership providers to better suit your requirements:
		* ActiveDirectoryProvider:	The default for Windows authenctication.
		* SqlMembershipProvider: 	Designed with flexibility in mind (mostly used for Forms).
	- When you want to override the "FormsAuthentication" class, consider three aspects:
		* The FormsAuthentication class does the work for setting the Forms ticket (cookie) for the first time.
		* The FormsAuthenticationModule does the ticket work on every subsequent request. It verifies if the cookie and ticket can be decrypted and added to the HttpContext for that request.
	- To implement a custom membership provider, you'll need to inherit the "MembershipProvider" abstract class from the "System.Web.Security" namespace.
	- The MembershipProvider inherits from the "ProviderBase" abstract class, so you must implement those also.
	- To use "WebSecurity" helpers with this provider, you'll need to inherit from the "ExtendedMembershipProvider".
	- With this solution, you must ensure that your queries include the "ApplicationName" value to get the appropriate user's information.









5.2 Configure and apply authorization
==============================================================================================================================

Creating roles
	Information:
	- MVC got default membership providers based on their related roles provider like SqlRoleProvider and ActiveDirectoryRoleProvider
	- Roles offer a way to arbitrarily group of users and most commonly this grouping is used for a more convenient way to apply authorization rules.


Authorizing roles by using configuration
	Information:
	- Instead of redeploying the application, you can adjust role settings in the Web.Config.
	- If you need the flexibility of defining roles in configuration, you must create that functionality.
	
	Code:
	-	<system.web>    
			<roleManager defaultProvider="AdminRoleProvider" enabled="true" cacheRolesInCookie="true">				
				<providers>            
					<clear/>            
					<add ... />       
				</providers>    
			</roleManager>
		</system.web>
			* Configuring an ASP.NET role provider.
	- 	public static void InitializeDatabaseConnection(string connectionStringName, string userTableName, string userIdColumn, string userNameColumn, bool autoCreateTables)
			* Only use this when using SimpleMembershipProvider with a SimpleRole.


Authorizing roles programmatically
	Information:
	- While the [Authorize] attribute returns you to the login screen, the WebSecurity.RequireRole will cause a 401.

	Code:
	-	[Authorize(Roles="Admin, User, ...")]
			* You can use this attribute to authorize roles programmatically.
	-	HttpContext.User.IsUserInRole("Admin");
			* Check if the user has a certain role.
	- 	Roles.GetRolesForUser();
			* Get all the roles of a user.
	-	RoleProvider.IsUserInRole("Admin");
			* Again, another way to validate the role.
	- 	WebSecurity.RequireRoles("Admin", "OtherRole");
			* You'll need all these roles otherwise a 401 is returned.


Creating custom role providers
	Information:
	- To create custom roles, you must inherit from the "RoleProvider" abstract class ("System.Web.Security"). This also inherits from the "ProviderBase" class ("System.Configuration.Provider").
	- The custom role provider will have multiple calls running concurrently, so you must write a thread-safe provider.
	- The roles must be secured in a cookie and typically you want to do that by using the <machineKey> configuration element of the server's Machine.config file.


Implementing WCF service authorization
	Information:
	- You manage WCF authenctication by passing user credentials to the WCF. They can be passed through from the user or they are a specific set just for your application.
	- The WCF service has the same options for authenctication as your MVC application, but because you're the client you'll need to take a different approach.
	- If you use application-level credentials, you must create a proxy to the WCF service by using the Add Service Reference command in Visual Studio.
	
	Code:
	- 	WCFServiceCient client = new WCFServiceCient();
		client.ClientCredentials.UserName.UserName = "Apps User Name";
		client.ClientCredentials.UserName.Password = "Apps Password";
			* Sending application-level credentials to a WCF service.
	- 	NetworkCredential credentials = new NetworkCredential();
		credentials.Domain = "windows domain";
		credentials.UserName = " Apps User Name";
		credentials.Password = " Apps Password";
		
		WCFServiceCient client = new WCFServiceCient();
		client.ClientCredentials.Windows.ClientCredential = credentials
			* Sending credentials to a WCF service using Windows authenctication.









5.3 Design and implement claims-based authenctication across federated identity stores
==============================================================================================================================

Implementing federated authenctication by using Windows Azure Access Control Service
	Information:
	- It's retired.
	
	
Creating a custom security token by using Windows Identity Foundation
	Information:
	- Windows Identity Foundation (WIF) is a framework for building identity-aware applications.
	- WIF is critical when trying to support single sign-on scenarios or to pass the burden and responsibility of authenctication to another application.
	- WS-Trust is a WS-* specification and OASIS standard that provides extensions to WS-Security; specifically dealing with the issuance, renewal and validation of security tokens.
	- WS-Federation is an extension to WS-Trust and it provides an architecture for ensuring the seperation between the formats of the tokens, the protocol for getting these tokens and the trust mechanisms that manage them all.
	- WIF can do the following things:
		* Build claims-aware applications (relying party applications).
		* Builds identity delegation support into claims-aware application. 
		* New identity and access tool for Microsoft Visual Studio 2012 that enables you to secure your application with claims-based identity and accept users from multiple identity providers. 
	- A security token service (STS) is the service component that builds, signs and issues security tokens according to the WS-Trust and WS-Federation protocols.
	- With WIF, you can create custom tokens (see page 308 for a good example of this).
	- When creating a custom token, you'll also need to create a custom token handler. This can be done by deriving from "SecurityTokenHandler". This has two main purposes:
		* CanReadToken(XmlReader): 		Reads and checks if the token is xml.
		* ValidateToken(SecurityToken):	Validates the token and checks it's signature (see page 309 for an example).

	Code:
	- 	public class MyCustomToken : SecurityToken {     
			public List<Claim> Claims {get; set;}      
			public XmlElemnt Signature {get; set;}     
			public bool ValidateThisSignature()     
			{         
				// code to validate the signature     
			}
		}
			* Managing a custom token in code.
	- 	<microsoft.identityModel>    
			<service>      
				<securityTokenHandlers>        
					<remove type="Microsoft.IdentityModel.Tokens.WindowsUserNameSecurityTokenHandler, Microsoft.IdentityModel" />        
					<add type="MyCustomToken.CustomUserNamePasswordValidatorSecurityTokenHandler, MyCustomToken" />      
				</securityTokenHandlers>    
			</service>  
		</microsoft.identityModel>
			* Add your custom token to the Web.Config.


Handling token formats for SAML and SWT tokens
	Information:
	- While it's cool and all, the exam document says that this is not needed.









5.4 Manage data integrity
==============================================================================================================================

Understanding encryption terminology
	Information:
	- Encryption refers to the transformation of readable or understandable text into an illegible format that can be decoded only when the appropriate key is provided to the system. 
	- Hashing is the process of applying a formula to a string of text, which produces a return value of fixed length that cannot be decrypted back into the original value.
	- Salting is a process that strengthens file encryption and hashes. It adds a random string to the beginning or end of the input text prior to hashing or encrypting the value
	- MD5 had a flaw where you could enter a fake password that was hashed the same way as the original one. Nowadays, we use SHA.
	- Data Encryption Standard (DES) is a symmetric-key algorithm but insecure. Use the successor to DES for better encryption: Advanced Encryption Standard (AES).
	- SSL uses Rivest, Shamir and Adleman (RSA) asymmetric encryption. 


Applying encryption to application data
	Information:
	- There are two main base classes that come from the "System.Security.Cryptography" namespace: "AsymmetricAlgorithm" and "SymmetricAlgorithm".
	- Symmetric algorithms namespaces in a nutshell (apply "Managed" behind them for managed classes):
		* System.Security.Cryptography.Aes
		* System.Security.Cryptography.DES
		* System.Security.Cryptography.RC2
		* System.Security.Cryptography.Rijndael
		* System.Security.Cryptography.TripleDES
	- Asymmetric algorithms namespaces in a nutshell (apply "Managed" behind them for managed classes):
		* System.Security.Cryptography.DSA
		* System.Security.Cryptography.ECDiffieHellman
		* System.Security.Cryptography.ECDsa
		* System.Security.Cryptography.RSA
	- When using symmetric cryptography classes, you will also use a special stream class called CryptoStream that encrypts or decrypts a stream of information.
	- Some rules that should be followed for both encryption standards:
		* Use unique keys for different business functions.
		* Protect your keys.
		* Ensure that your keys are not with your data.
		* Configure keys to expire.

	Code:
	-	using (RijndaelManaged rijndaelManaged = new RijndaelManaged()) {     
			// assumes that the key and initialization vectors are already configured     
			CryptoStream crypoStream = new CryptoStream(myManagedStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write); 
		};
		* Encrypt data symmetric.
	- 	using (RijndaelManaged rijndaelManaged = new RijndaelManaged()) {     
			// assumes that the key and initialization vectors are already configured    
			CryptoStream crypoStream = new CryptoStream(myManagedStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Read); 
		};
		* Decrypt data symmetric.
	-	using (RSACryptoServiceProvider RSA = new RSACryptoServiceProvider()) {        
			RSA.ImportParameters(RSAKeyInfo);         
			encryptedData = RSA.Encrypt(DataToEncrypt, DoOAEPPadding);         
			decryptedData = RSA.Decrypt(encrypyedData, DoOAEPPadding);    
		};
		* Encrypt and decrypt data asymmetric. The DoOAEPPadding stands for a boolean value to perform direct RSA encryption using Optimal Asymmetric Encryption Padding (OAEP).


Applying encryption to configuration sections of an application
	Information:
	- There are two configuration providers that manage encryption and decryption of the Web.Config file:
		* DPAPIProtectedConfigurationProvider: 	Uses the Windows Data Protection API (DPAPI).
		* RsaProtectedConfigurationProvider:	Uses the RSA encryption algorithm.
	- Use the RsaProtectedConfigurationProvider when you want identical encrypted configuration files on multiple servers because you can export and import the encryption keys.
	- Specify which provider you want to use in the Web.Config or the Machine.Config with the ProtectedConfigurationProvider.

	Code:
	- 	aspnet_regiis -pe "ConnectionStrings" -app "/MachineDPAPI" -prov "RsaProtectedConfigurationProvider"
			* Using the aspnet_regiis.exe tool with the provider encryption (-pe) command to encrypt sections of the Web.Config file.
	-	<machineKey validationKey="2B746511891C1BAF47F8D25C07F6C39A104696DB51F17C529AD3CABE" decryptionKey="FBF50941F22D6A3B229EA593F24C41203DA6837F1122EF17" />
			* Add the machine key, because otherwise it is unable to decrypt the configuration information.
	-	aspnet_regiis -pd "ConnectionStrings" -app "/MachineDPAPI" -prov "RsaProtectedConfigurationProvider"
			* Decrypt the data with the provider decryption (-pd) command.


Signing application data to prevent tampering
	Information:
	- With a digital signature, you achieve authenctication, authorization and nonrepudiation:
		* Nonrepudiation is the ability to prove that an authenticated party is the same party that took a particular action.
	- The .NET framework combines both encryption and digital signature in the AsymmetricAlgorithm class. 

	Code:
	-	// create the hash code of the text to sign
		SHA1 sha = SHA1.Create(); 
		byte[] hashcode = sha.ComputeHash(TextToConvert); 
		
		// use the CreateSignature method to sign the data
		DSA dsa = DSA.Create();         
		byte[] signature = dsa.CreateSignature(hashcode);
			* Creates a hash and and signature using the System.Security.Cryptography.DSA class.
	-	// create the hash code of the text to verify
		SHA1 sha = SHA1.Create(); 
		byte[] hashcode = sha.ComputeHash(TextToVerify); 
		
		// use the VerifySignature method to verify the DSA signature
		DSA dsa = DSA.Create();
		bool isSignatureValid = dsa.VerifySignature(hashcode, signature);
			* Verify the hash and signature using the System.Security.Cryptography.DSA class.









5.5 Implement a secure site with ASP.NET
==============================================================================================================================

Securing communication by applying SSL certificates
	Information:
	- To create an SSL connection, a web server requires an SSL certificate, which is a "public key certificate" but can also be named as "digital certificate" or "identity certificate".
	- A certificate is a document that uses a signature to stronly link an identity to a public key. The identity information contains details including the name and address of the organization/person and more.
	- In a public key infrastructure (PKI), the signed signature is from a third-party source, which is the certificate authority (CA). 	
	- A signature can be issued by another web user, called an endorsement or from the originating user, called a self-signed certificate.
	- You can request a certificate from IIS and you'll need two keys: a private and a public key.


Salting and hashing passwords for storages
	Information:
	- Common password attacks are:
		* Dictionary attack: 	Contains a list of words, common passwords and other stuff that will be hashed and compared to a file.
		* Brute-force attack:	Applies hashed values of random characters to the list of hacked passwords to attempt to find a match.
		* Rainbow table:		Rather than using randomly defined values as in a brute-force attack, a rainbow table attack uses a dictionary of values and hashes them on the fly.
	- Salts can be added in a password every time (stored in the db with the passwords) or they can be appended to the front of back of the password.
	- The salt should be at least as long as the output of the hashing function (SHA265 => 32 bytes => salt of 32 bytes).
	- Use the RNGCryptoServiceProvider.GetBytes() for a high level of randomness.
	- Password-Based Key Derivation Function 2 (PBKDF2) uses a function such as Hash-based Message Authentication Code (HMAC), cipher, or another pseudo-random func-tion and applies it to the value being hashed, along with a salt.
	- The PBKDF2 iterative hashed salt is then repeated multiple times, generally a minimum of 1,000 times, to get a value. This value is then used as the cryptographic key in subsequent operations.
	- Working with the key-stretched hashed values, users can't see there old passwords anymore. When resetting, use a email validation or some kind of one-use token.

	Code:
	- See page 330 for a really great example of key-stretched hashed values.


Using HTML encoding to prevent cross-site scripting attacks (AntiXSS Library)
	Information:
	- Javascript injection finds place by abusing the address bar or finding a cross-site scripting (XSS).
	- AntiXSS (end of life because of alternatives) is a library that could be used for encoding stuff.
	
	Code:
	- 	<% Html.Encode(review.Title) %>
			* Make sure that malicious code is rendered as text.
	-	public ActionResult Create(string message) {      
			var newEntry = new Entry();     
			newEntry.Message = Server.HtmlEncode(message);
		}
			* C# equilevant of html encoding text.


Implement deferred validation and handle unvalidated requests
	Information:
	- Deferred validation (also known as "lazy request validation" will only validate the object when needed.

	Code:
	-	<httpRuntime requestValidationMode="4.5" ... />
			* Enable deferred validation mode.
	- 	var s = context.Request.Unvalidated.Form["some_value"];
			* Access unvalidated objects in the request.


Preventing SQL injection attacks by parameterizing queries
	Information:
	- To counter SQL injection attacks, you need to do the following:
		* Always inspect the data.
		* Use type-safe SQL parameters when accessing your database.
		* Use restriced accounts when accessing the database.
		* Don't show database errors to the public.
	- While it's possible to do query composition with Linq, this composition is through the object model, so there are no facilities to insert input text as anything other than a string value.
	
	Code:
	- 	SqlDataAdapter adapter = new SqlDataAdapter("AuthorLogin", conn); 
		adapter.SelectCommand.CommandType = CommandType.StoredProcedure; 
		SqlParameter param = adapter.SelectCommand.Parameters.Add("@id", SqlDbType.VarChar, 11); 
		param.Value = submittedId;
			* Using the Parameters collection in SQL Server.
	-	SqlDataAdapter adapter = new SqlDataAdapter("SELECT username, email FROM user WHERE id = @id", conn); 
		SQLParameter param = adapter.SelectCommand.Parameters.Add("@id", SqlDbType.VarChar, 11); 
		paarm.Value = submittedId;
			* Using parameters with dynamic SQL.


Preventing cross-site request forgeries (XSRFs)
	Information:
	- Cross-site request forgery (XSRF), or cross-site reference forgery (CSRF), works by exploiting the trust that a site has for the user.
	- Request forgery can be done by injecting JavaScript or HTML into the site, email, or some other form that when clicked or viewed causes the unanticipated action
	- Calling the AntiForgeryToken method from a form and adding the ValidateAntiForgeryTokenAttribute attribute to the action method, you can protect yourself from CSRF.
	- Must have cookies enabled for this to work.

	Code:
	-	[ValidateAntiForgeryToken] 
			* Apply this attribute to the action you want to call.
	- 	@using (Html.BeginForm("Login", "Authorize"))
		{   
			@Html.AntiForgeryToken();
		}
			* Apply the @Html.AntiForgeryToken to send the forgery token. This results in:
				+ 	<form action="..." method="post">  
						<input name="__RequestVerificationToken" type="hidden" value="J58uHtyhGtyHgf8kkjgFDeRgjjKKk6khgCvb/ywruFIUUYYVHHHgfft87/gGsQUf/YuP" />    
						<!-- your form fields. -->    
						<input type="submit" value="Submit"/>
					</form>
					


























