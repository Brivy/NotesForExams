3.1 Plan for search engine optimization and accessibility
==============================================================================================================================

Using analytical tools to parse HTML
	Information:
	- You can use the SEO Toolkit to examine HTML and fix issues that it returns and do more:
		* Create sitemaps
		* Create robot exclusion rules
		* Create a robot.txt file which tells the search engines not to index a certain page.
	- Other tools are:
		* Bing Webmaster Tools to evaluate the <head> tag.
		* Google Webmaster Tools to evaluate everything but you need access to the server.
		* World Wide Web Consortium (W3C) offers some tools for HTML, CSS, feed formats and mobility.
		* Page Inspector in Microsoft Visual Studio for evaluating HTML and looking for potential issues.


Viewing and evaluating conceptual structure by using plugs-in for browsers
	Information:
	- The three major components of rendered HTML pages are:
		* Content: text, images, videos and similar information.
		* Presentation: styles and other information related to the look and feel of the site.
		* Functionality: Client-side scripts such as Javascript.
	- It is easier to parse a page when the script sections are moved to a different file.


Writing semantic markup for accessibility
	Information:
	- WAI-ARIA:
		* Web Accessibility Initiative: 			Trying to make web more accessible, enabling people with disabilities to participate equally.
		* Accessible Rich Internet Applications):	Provinding additional context to HTML elements and thus to the content they contain.
	- Only use ARIA when payload is not critical.
	- ARIA tries to do four major things:
		* Keyboard focus and navigation.
		* Relationships.
		* Managing dynamics changes.
		* Role of presentation.
	- The ARIA "role="button" attribute markes an element as a button for screen readers.
	- You can also change a role attribute to make it something else for screen readers like "role="heading".
	- Because MVC is limited in ARIA support, you can extend HTML helpers to make them work.D
	
	Code:
	- public static IHtmlString ARIATextBoxFor<TModel, TProperty>(this HtmlHelper<TModel> helper, Expression<Func<TModel, TProperty>> exp) { ... }
		* Extending the @Html.TextBoxFor method.
		







3.2 Plan and implement globalization and localization
==============================================================================================================================

Planning a localization strategy
	Information:
	- Language (Tries to match this one secondly) -> Locale (Tries to match this one first) => English -> UK/Using
	- Using the header "Accept-Language" will determine which language is requested.
	- The easiest way for globalization is using resource files. For this to work you will need to call the ResourceManager helper class.
	- Resource files can also be used to localize views. To use this, you can create an override of the "Controller.OnActionExecuted" and change the path:
		* /Views/Globalization/en-US/Home/Index.cshtml
		* /Views/Globalization/en-MX/Home/Index.cshtml
	
	Code:
	- <globalization culture="auto" uiculture="auto" enableclientbasedculture="true"/>
		* A setting in the Web.Config to get the specific culture out of the "Accept-Language" header.


Creating and applying resources to the UI
	Information:
	- Two approaches of managing resource files:
		* Single resource file for each language.
		* Multiple resource files.
	- Use the "globalize.js" and the "globalize.cultures.js" of jQuery for globalization in javascript.
	
	Code:
	- 	var language = "@Request.UserLanguages[0]";
		<script>jQuery.preferCulture(language);</script>
			* Determine and set the language in javascript for the globalization (JS can't detect language automatically).
	- $.global.preferCulture(language) 
		Set the global culture.


Setting cultures
	Code:
	- Thread.CurrentThread.CurrentUICulture = new CultureInfo("es-MX");
		* Change the culture of someone manually.


Creating satellite resource assemblies
	Information:
	- Two primary approaches for culturally aware applications:
		* Put everything in one assembly. Only do this when you don't have to many or large resource files
		* Create satellite assemblies.
	- Satellite assemblies have the following naming conventions: <resource_name>.<culture_identifier>.resource

	Code:
	- al.exe /t:lib /embed:strings.de-DE.resources /culture:de-DE /out:MyApp.de-DE.resources.dll
		* Creates an satellite assembly.
	- static ResourceManager rm = new ResourceManager("strings", Assembly.GetExecutingAssembly());
		* Load the assembly in MVC.









3.3 Design and implement MVC controllers and actions
==============================================================================================================================

Applying authorization attributes and global filters
	Information:
	- Some attributes that can help in the MVC flow:
		* RequireHttpsAttribute:				All controllers/methods that have been decorated with these filters can only be accessed with HTTPS.
		* ValidateAntiForegeryTokenAttribute:	Protects against cross-site forgery with a token. That ensures that it's the same browser section and matches an expected value on the server.
		* ValidateInputAttribute:				Decorating a models property with "[ValidateInput(true, Exclude = "ArbitraryField")]" will let a client stop posting potentially dangerous content.
		* AuthorizeAttribute:					An user should be authenticated before moving on and must have the correct role. The ones within a controller that can be accessed by everyone are marked with "[AllowAnonymous]".
		* ChildActionOnlyAttribute:				You can't access an action with traditional mapping when this is applied. Only can be called from "Action" or "RenderAction" HTML extension methods.
		* HandleErrorAttribute:					Handles thrown errors by showing the "~/Views/Shared/Error" views. You can set different properties like ExceptionType, View and Master to show different views.
		* ActionFilterAttribute:				Is an abstract class that can be inherited to create your own filters:
			+ OnActionExecuting:					Called before the action is called. Gives you an opportunity to look at the HttpContext.
			+ OnActionExecuted:						Called after the results of the action are known. 
			+ OnResultExecuting:					Called before the action result from the action is processed.
			+ OnResultExecuted:						Called after the action result is processed but before the output is loaded into the response stream.
		* InitializeSimpleMembershipAttribute:	Initializes the database to ensure that the applicaiton can reacht the database and that the database schema is correct.
	- You can mark a custom filter to be run only once through the "AllowMultiple" parameter in the "AttributeUsage" attribute on the filter class: "AllowMultiple = false".
	- Apply the filters at the following places:
		* Controllers
		* Methods
		* Globally by adding it to the "App_Start/FilterConfig.cs" RegisterGlobalFilters method (filters.Add(new RequireHttpsAttribute());).
		
Implementing action behaviors
	Information:
	- Order of filters is good to keep in mind. Apply first the one that is most likely to fail (Authentication) and continue from there.


Implementing action results
	Information:
	- The "ActionResult" class performs the last set of conversions on information before it's returned to the client.
	- But there are more:
		* ContentResult			-> 		Content 				-> 	Returns a user-defined content type.
		* EmptyResult			->		(None)					-> 	Represents a return value to be used if the action method must return a null result.
		* FileResult			->		File					-> 	Returns binary output that is written to the result.
		* JavaScriptResult		->		Javascript				->	Returns Javascript that is executable on the client.
		* JsonResult			->		JSON					->	Returns a serialized Javascript Object Notation (JSON) object.
		* PartialViewResult		->		PartialView				->	Renders a partial view.
		* RedirectResult		->		Redirect				->	Redirects to another action method by using its URL and passing through the routing process.
		* RedirectToRouteResult	->		RedirectToAction/Route	->	Redirects to another action method.
		* ViewResult			->		View					-> 	Renders a view as an HTML document.
	- ViewResultBase is used for ViewResult and PartialViewResult.
	- When ContentResult is completed into FileResult, it has two properties:
		* ContentType: 		The type of content that we are sending.
		* FileDownloadName: The name of the downloaded file.
	
	Code:
	- ViewData["UserName"] = "Brain";
		* Work with viewdata.


Implementing model binding
	Information:
	- There are different approaches you can take with model binding:
		* Strongly-typed binding.
			+ This binding has an advantage because MVC knows what model it should bind.
			+ It uses model attributes to render HTML from the HTML helper. 
			+ Using strongly-typed helper tags, makes sure the UI is completly validated.
		* Weakly-typed binding.
			+ Has a performance hit because it has to find the property you are requesting.
			+ Can be usefull when working in parallel on the front- and backend.
			+ Can make use of the Bind attribute.
		* Value provider.
	- There are other ways to bind a browser request to an object:
		* DefaultModelBinder:	 	Maps a browser request to a standard data object.
		* LinqBinaryModelBinder: 	Maps a browser request to a language-Integrated Query (LINQ) object.
		* ModelBinderAttribute:		An attribute that associates a model type to a model-builder type.
		* ModelBinderDictionary:	Represents a class that contains all model binders for the application, listed by binder type.
	- Using the "ValueProvider" object enables you to take advantage of model binding.
		* FormsValueProvider:				Enables you to work with the data returned as form values.
		* QueryStringProvider: 				Enables you to work with items in the query string.
		* HttpFileCollectionValueProvider:	Enables you to work with any attachments that might be included with the request.
		* RouteDataValueProvider: 			Enables you to work with the routing data, or URL.

	Code:
	- @Html.TextBox("model.UserName")
		* Weakly-typed property in a razor page.
	- Public ActionResult Login([Bind(Prefix="login")]LoginUser user)
		* When an incoming value references "login", there is an explicit map to the user object that it already understands.
	- Public ActionResult Save([Bind(Exclude="Salary")]Employee emp)
		* Exclude a property when using weakly-typed binding.
	- 	if (TryUpdateModel(emp, formColl.ToValueProvider())	{        
			UpdateModel(emp, formColl.ToValueProvider());    
		}
		* Update a model based on the form data with the default value provider.









3.4 Design and implement routes (MVC 5 can also use attribute routing, just saying)
==============================================================================================================================

Defining a route to handle a URL pattern
	Information:
	- You'll need to add routes to the RouteCollection object. The default handler of this is called RegisterRoutes and can be found can in "App_Start/RouteConfig.cs".
	- Using the extension method MapRoute with the required parameters name and URL pattern, you can manage this process.
	- The default pattern is as follows: {controller}/{action}/{id}.
	
	Code:
	- routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
		* Ignores a specific route.
	-	routes.MapRoute(
			name: "Default",
			url: "{controller}/{action}/{id}",
			defaults: new { controller = "Home",
				action = "Index", id = UrlParameter.Optional },
			constraints: new { id = @"\d+" }
		);
		* A default map route.

Applying route constraints
	Information:
	- Using regex, you can add constraints to the .MapRoute method.
	
	Code:
	-	constraints: new {id = @"[a-zA-Z]+"});
		constraints: new {id = @"\d+"});
		* Two constraints used by two different MapRoute functions that will handle the ID differently.
		
		
Ignoring URL patterns
	Information:
	- Add the routes.Ignore always before the other routes.
	- For example, restrict the route to a folder containing PDF files and let an action return FileContentResult handle it.
	
	Code:
	- routes.Ignore("{*allhtml}", new {allhtml=@".*\.htm(/.*)?});
		* Ignores .htm or .html files.


Adding custom route parameters
	Information:
	- The URL "Article/List/1-1-2013" matches the route List(DateTime date) while the URL "Article/List/1-1-2013/" matches List(DateTime date, DateTime? enddate).


Defining areas
	Information:
	- Areas enbables the designer to separate a normal set of controllers, views and models into separate functional groups in the project and local file structure.
	- An area automatically contains it's own route file (for example: "AreaName"AreaRegistration.cs) that will route requests to this.
	








3.5 Control application behavior by using MVC extensibility points
==============================================================================================================================

Implementing MVC filters and controller factories
	Information:
	- There are four major filter types:
		* Authorization: 	Makes a security-based evaluation about whether an action method should be executed.
		* Action: 			Enables the developer to wrap the execution of the action method.
		* Result: 			Enables the developer to do extra processing of the results from an action method.
		* Exception: 		Runs when there is an unhandled exception thrown in the processing of an action method.
	- Add a custom attribute to the "RegisterGlobalFilters" method in the "App_Start/FilterConfig" to ensure that they will run on every action method.
	- You can create a custom "ControllerFactory" class that implements the "System.Web.Mvc.IControllerFactory". This has three methods:
		* CreateController: 			Handles the actual control creation.
		* ReleaseController: 			Cleans the controller up.
		* GetControllerSessionBehavior: Defines and control how the controller works with session.
	
	Code:
	- [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
		* Defines some special properties and restrictions when creating attributes.
	- ControllerBuilder.Current.SetControllerFactory(typeof(MyCustomControllerFactory());
		* Register a custom controller factory in the "Global.asax" file (under the Application_Start() method).


Controlling application behavior by using action results
	Information:
	- To create a new custom action result, you need to inherit "System.Web.Mvc.ActionResult" and override the ExecuteResult method.
	
	Code:
	- context.HttpContext.Response.Write("Test");
		* Overwrite a result with your own.


Controlling application behavior by using view engines
	Information:
	- Inherit the class "System.Web.Mvc.VirtualPathProviderViewEngine" when you want to overwrite the current view engine.
	- For a complete overhaul, you can implement the IViewEngine interface with the following methods:
		* FindView
		* FindPartialView
		* ReleaseView
	- When you only add new stuff or simply change the path from which the views are pulled, there is no need to create custom views. But when heavily changing the engine, you will need to create custom views.
	- Implement the "System.Web.Mvc.IView" interface with the following method for a custom view:
		* Render: Takes a "System.IO.TextWriter" and a "System.Web.Mvc.ViewContext" object as parameter.
			+ TextWriter is used to get the parsed and rendered information into the HttpResponse object.
			+ ViewContext contains information about the HttpContext, ViewBag and FormData objects.
	
	Code:
	- ViewEngines.Engines.Add(new CustomViewEngine());
		* Register a new "CustomViewEngine" in the Application_Start file.


Controlling application behavior by using model binders
	Information:
	- Inherit the class "System.Web.Mvc.DefaultModelBinder" when you want to overwrite the current model binder.
	- Implement the "System.Web.Mvc.IModelBinder" interface if you want to create a new model binder, but not overwrite the default one.
	
	Code:
	- ModelBinders.Binders.DefaultBinder = new DropDownDateTimeBinder();
		* Register the new modelbinder as your default one.
	- ModelBinders.Binders.Add(typeof(MyNewModelBinder), new MyNewModelBinder ());
		* Add a modelbinder to the modelbinders group instead of overwriting the default one.


Controlling application behavior by using route handlers
	Information:
	- Inherit from the "System.Web.Mvc.MvcRouteHandler" class to overwrite the current route handler.
	- The most important method to overwrite is GetHttpHandler which enables you to examine the values and change them.
	- Implement the "System.Web.Routing.IRouteHanlder" if you want to create a new route handler.
	
	Code:
	- routes.MapRoute( ... ).RouteHandler = new MyCustomRouteHandler();
		* Add a custom route handler to your route.
	- 	Route watermarkRoute = new Route("images/{name}", new WaterMarkRouteHandler("CodeClimber - 2011")); 
		routes.Add("image", watermarkRoute);
		* Add a new route handler to your route.









3.6 Reduce network bandwidth
==============================================================================================================================

Bundling and minifying scripts
	Information:
	- Main purpose of bundling is to minimize the bandwidth and connections needed to download files to the client.
	- With minification you will clean out white spaces, comments, line returns and other extraneous content in exchange for smaller file size. But this also obfuscates the files.
	- The advantage of bundling only works the first time; after that, the browser will cache it.
	- Problem with bundles is that it takes more time to find functions within the bundles. This is not only on the first time visiting.
	- Because bundeling a bunch of scripts generates a hashtag, the browser will keep the files longer in cache until they are expired (1 year) or changed.
	- Alternative way of enabeling minification is to add "BundleTable.EnableOptimizations = true;" at the bottom of the RegisterBundles method in your "App_Start/BundleConfig.cs" file.

	Code:
	- bundles.Add(new ScriptBundle("~/bundles/myBundle").Include("~/Scripts/myScript1.js, "~/Scripts/myScript2.js, "~/Scripts/myScript3.js"));
		* Bundle scripts together in the BundleConfig.cs.
	- @BundleTable.Bundles.ResolveBundleUrl(("~/bundles/myBundle")
		* Apply the bundle in your view.
	- <compilation debug="false" />
		* Enable minification of your files.


Compressing and decompressing data
	Information:
	- The "Accept-Encoding" header gives information on alternative encoding types that the browser can understand like "gzip" or "deflate".
	- You can change the way compression works in IIS where you can for example set if you want to compress static or also dynamic content.
	- There are two ways of using ASP.NET MVC to zip files on the fly:
		* Create local temporary files and return it as a FileResult.
		* Using "System.IO.Compression.GZipStream" to compress your file. 


Planning a content delivery network (CDN) strategy
	Information:
	- CDNs provide a way to distribute your content from sources other than your server.
	- Purpose of CDNs are to get the content closer to the client.
	- You can get many minified Javascript to load in your application by their CDNs.
















