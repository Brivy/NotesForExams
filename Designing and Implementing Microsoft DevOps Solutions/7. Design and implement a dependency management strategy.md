# Design and implement a dependency management strategy

Dependency management in software development

## Explore package dependencies

Dependencies, dependencies, dependencies...

### What is dependency management?

Projects have dependencies on other projects, and solutions aren't single pieces of software. Each component can have its maintainers, speed of change, and distribution, giving both the creators and consumers of the components autonomy.

With all dependencies being managed, it's also possible to control the consumed dependencies, enabling governance and security scanning to use known vulnerabilities or exploits packages.

### Describe elements of a dependency management strategy

There are many aspects of a dependency management strategy.

* **Standardization**: Managing dependencies benefit from a standardized way of declaring and resolving them in your codebase. Standardization allows a repeatable, predictable process and usage that can be automated as well.
* **Package formats and sources**: The distribution of dependencies can be performed by a packaging method suited for your solution's dependency type. Your dependency management strategy should include the selection of package formats and corresponding sources where to store and retrieve packages.
* **Versioning**: Just like your own code and components, the dependencies in your solution usually evolve. It requires a versioning mechanism for the dependencies to be selective of the version of a dependency you want to use.

### Understand source and package componentization

Current development practices already have the notion of componentization. There are two ways of componentization commonly used.

* **Source componentization**: The first way of componentization is focused on source code. It refers to splitting the source code in the codebase into separate parts and organizing it around the identified components.
* **Package componentization**: The second way uses packages. Distributing software components is performed utilizing packages as a formal way of wrapping and handling the components.

### Decompose your system

The goal of decomposing is to reduce the size of your codebase and system, making it more efficient to build and manageable in the end.

It may require some refactoring, such as creating new solution artifacts for code organization or code changes to cater for the unchanged code to take a dependency on an (external) component.

### Scan your codebase for dependencies

There are several ways to identify the dependencies in your codebase. These include scanning your code for patterns and reuse and analyzing how the solution is composed of individual modules and components:

* **Duplicate code**: Just keep in mind that code duplication isn't necessarily a bad practice.
* **High cohesion and low coupling**.
* **Individual lifecycle**.
* **Stable parts**.
* **Independent code and components**.

## Understand package management

Learn about package feeds, common public package sources, and how to create and publish packages.

### Explore packages

A package is a formalized way of creating a distributable unit of software artifacts that can be consumed from another software solution. The package describes the content it contains and usually provides extra metadata, and the information uniquely identifies the individual packages and is self-descriptive.

There are a couple of options nowadays:

* **NuGet packages**: Used for .NET environment. It includes .NET assemblies and related files, tooling, and sometimes only metadata. A NuGet package is essentially a compressed folder structure with files in ZIP format and has the .nupkg extension.
* **NPM**: Used for JavaScript development. It is a file or folder containing JavaScript files and a package.json file describing the package's metadata. For node.js, the package usually includes one or more modules that can be loaded once the package is consumed.
* **Maven** Used for Java-based projects. Each package has a Project Object Model file describing the project's metadata and is the basic unit for defining a package and working with it.
* **PyPi**: The Python Package Index, abbreviated as PyPI and known as the Cheese Shop, is the official third-party software repository for Python.
* **Docker**: Other kinds of packages.

### Understand package feeds

The centralized storage for packages is commonly called a **package feed**. There are other names in use, such as repository or registry. The feeds are centralized and available for many different consumers. Depending on the package, purpose, and origin, it might be generally available or to a select audience (public and private feeds).

Public feeds can be anonymously accessible and optionally authenticated while private feeds can be accessed only when authenticated.

There are two options for private feeds:

* **Self-hosting**: Some of the package managers are also able to host a feed. Using on-premises or private cloud resources, one can host the required solution to offer a private feed.
* **SaaS services**: A variety of third-party vendors and cloud providers offer software-as-a-service feeds that can be kept private. It typically requires a consumption fee or a cloud subscription.

See here some options for private hosting:

| Package type | Self-hosted private feed                | SaaS private feed                      |
|--------------|----------------------------------------|---------------------------------------|
| NuGet        | NuGet server, Azure Artifacts, MyGet   | NPMjs, MyGet, Azure Artifacts          |
| NPM          | Sinopia, CNPMjs, Verdaccio             | NPMjs, MyGet, Azure Artifacts          |
| Maven        | Nexus, Artifactory, Archivia           | Azure Artifacts, Bintray, JitPack      |
| Docker       | Portus, Quay, Harbor                   | Docker Hub, Azure Container Registry, Amazon Elastic Container Registry |
| Python       | PyPI Server                            | Gemfury                               |

### Consume packages

