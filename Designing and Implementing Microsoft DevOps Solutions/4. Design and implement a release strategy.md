# Design and implement a release strategy

Probably some CI/CD stuff.

## Introduction to continuous delivery

First some CD stuff.

### Explore IT development cycle

The more we change, the more risk it leads to, and we're back at the beginning, on many occasions resulting in yet another document or process that should be followed. This is sometimes called *silo-based development*:

![Cool picture](Pictures/silo-based-development-89924c5a.png)

All the value is released at the same time. As a result, the release takes a long time.

That's why we want **Continuous Delivery (CD)**. It's a set of processes, tools, and techniques for rapid, reliable, and continuous software development and delivery. Below are *the eight principles of continuous delivery*:

* The process for releasing/deploying software must be repeatable and reliable.
* Automate everything!
* If something is difficult or painful, do it more often.
* Keep everything in source control.
* Done means "released."
* Build quality in!
* Everybody has responsibility for the release process.
* Improve continuously.

This isn't done only by making a cool automated pipeline, but you'll also need to consider the following:

* Software architecture (monoliths are hard to deploy).
* Testing strategy (manual tests don't scale well).
* Organization (separated business and IT departments don't work smoothly), and so forth.

Continuous delivery is an enabler for *DevOps*. DevOps focuses on organizations and bringing people together to build and run their software products.

### Move to continuous delivery

Instead of following the traditional software development, we can practice CD:

![Cool picture](Pictures/continuous-delivery-4e7ce134.png)

Compared to the previous picture, the value isn't piled up and released all at once but flows through a pipeline. Here, only one part of the work can flow through the pipeline at once.

Work must be prioritized in the right way. As you can see, the pipeline has green and red outlets. These are the feedback loops or quality gates that we want to have in place. A feedback loop can be different things:

* A unit test to validate the code.
* An automated build to validate the sources.
* An automated test on a Test environment.
* Some monitor on a server.
* Usage instrumentation in the code.

The more that is automated, the faster value flows through the pipeline.

### Understand releases and deployments

A **release** is a package or container containing a versioned set of artifacts specified in a release pipeline in your CI/CD process. It includes a snapshot of all the information required to carry out all the tasks and actions in the release pipeline, such as:

* The stages or environments.
* The tasks for each one.
* The values of task parameters and variables.
* The release policies such as triggers, approvers, and release queuing options.

There can be multiple releases from one release pipeline (or release process).

A **deployment** is the action of running the tasks for one stage, which results in a tested and deployed application and other activities specified for that stage. Starting a release starts each deployment based on the settings and policies defined in the original release pipeline.

### Separating technical releases from functional releases

When we want to separate the technical and functional release, we need to start with our software itself. The software needs to be built so that new functionality or features can be hidden from end users while it's running (mostly by using **feature toggles**).

The whole idea of separating deployment from release (exposing features with a switch) is compelling and something we want to incorporate in our Continuous Delivery practice. It helps us with more stable releases and better ways to roll back when we run into issues when we have a new feature that produces problems.

### Understand release process versus release

The *release process/pipeline* contains all the steps you walk through when you move your artifact from one of the artifact sources discussed earlier through the stages or environments. The stage can be a development stage, a test stage, a production stage, or a stage where a specific user can access the application.

The *release* itself is something different. The release is an instance of the release pipeline. Each release is unique and requires its own instance of the pipeline to ensure that it goes through the necessary stages and tasks to be successfully deployed to production.

## Create a release pipeline

Azure Pipelines capabilities, build and release tasks, and multi-configuration and multi-agent differences.

### Describe Azure DevOps release pipeline capabilities

There are three pipeline options. I'm only going to describe the differences between the two most used onces:

TODO: NEED TO CHECK WHAT I NEED HERE

### Explore release pipelines

A simple release pipeline looks like this:

![Cool picture](Pictures/pipeline-7793ffc6.png)

The first component in a release pipeline is an **artifact**:

* The most common source is a package from a build pipeline.
* Another commonly seen artifact source is, for example, source control.

A release pipeline has a **trigger** which is the mechanism that starts a new release:

* A manual trigger, where people start to release by hand.
* A scheduled trigger, where a release is triggered based on a specific time.
* A continuous deployment trigger, where another event triggers a release. For example, a completed build.

Another vital component of a release pipeline is **stages** or sometimes called **environments**. It's where the artifact will be eventually installed.

Another component of a release pipeline is **approval**. People often want to sign a release before installing it in the environment, but you can also replace this by an automatic process.

Finally, we have the **tasks** within the various stages. The tasks are the steps that need to be executed to install, configure, and validate the installed artifact.

### Explore artifact sources

In general, the idea about build and release pipelines and Continuous Delivery is to build once and deploy many times. It means that an *artifact* will be deployed to multiple environments. The contents of the package should never change. It's what we call **immutability**. You identify an immutable package by giving it a version so that you can refer to it at a later stage (for example with [*Semantic Versioning*](https://semver.org/)).

![Cool picture](Pictures/artifact-sources-97b67122.png)

The most common way to get an artifact within the release pipeline is to use a **build artifact**. The build pipeline compiles, tests, and eventually produces an immutable package stored in a secure place (storage account, database, and so on). The release pipeline then uses a secure connection to this secured place to get the build artifact and do extra actions to deploy it to an environment. The significant advantage of using a build artifact is that the build produces a *versioned artifact*.

The release is related to a specific commit in our **version control** system. With that, we can also see which version of a file or script is eventually installed. In this case, the version doesn't come from the build but from version control.

Another possibility of an artifact source can be a **network share** containing a set of files. However, you should be aware of the possible risk. The risk is that you aren't 100% sure that the package you're going to deploy is the same package that was put on the network share.

Finally, **container registries** are a rising star regarding artifact sources. Container registries are versioned repositories where container artifacts are stored. Pushing a versioned container to the content repository and consuming that same version within the release pipeline has more or less the same advantages as using a build artifact stored in a safe location.

## Explore release recommendations

Contains critical release strategy recommendations organizations must consider when designing automated deployments.

### Understand the delivery cadence and three types of triggers

Release and stages make use of triggers. There are three types of triggers we recognize:

* *Continuous deployment trigger*: can be used to trigger every time a build completes and creates a new release.
* *Scheduled triggers*: Allows you to set up a time-based manner to start a new release
* *Manual trigger*: a person or system triggers the release based on a specific event.

### Explore release gates

*Release gates* are a set of predefined criteria or checkpoints used in software development and deployment processes to ensure that a software product or feature meets specific quality standards before it is released to the end-users. These criteria often include successful completion of tests, code reviews, performance benchmarks, and security audits. Release gates help minimize the risk of shipping faulty software, improve overall product quality, and maintain a consistent user experience.

As an example:

* Pre-deployment gates ensure no active issues in the work item or problem management system before deploying a build to an environment.
* Post-deployment gates ensure no incidents from the app's monitoring or incident management system after being deployed before promoting the release to the following environment.
