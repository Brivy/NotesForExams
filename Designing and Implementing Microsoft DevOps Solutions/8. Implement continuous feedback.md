# Implement continuous feedback

Stuff regarding the continuous feedback concept.

## Implement tools to track usage and flow

Continuous feedback practices and tools to track usage and flow.

### Understand the inner loop

The easiest way to define **the inner loop** is the iterative process that a developer does when writing, building, and debugging code.

![Cool picture](Pictures/inner-loop-f38b24da.png)

It differs per developer. C# developers have a different inner loop then web developers:

![Cool picture](Pictures/different-inner-loop-5e065ff3.png)

The steps within the inner loop can be grouped into three broad buckets of activity - *experimentation*, *feedback collection*, and *tax*.

C# developers have for example the following steps:

* Coding (Experimentation) -> only one that adds customer value.
* Building (Feedback Collection)
* Testing / Debugging (Feedback Collection)
* Committing (Tax) -> Necessary to work, but doesn't provide value nor feedback.

![Cool picture](Pictures/understand-loop-c756f050.png)

Some general statements:

* You want to execute the loop as fast as possible and for the total loop execution time to be proportional to the changes made.
* You want to minimize the time feedback collection takes but maximize the quality of the feedback that you get.
* You want to minimize the tax you pay by eliminating it where it's unnecessary to run through the loop (can you defer some operations until you commit, for example).
* As new code and more complexity are added to any codebase, the amount of outward pressure to increase the size of the inner loop also increases. More code means more tests, which means more execution time and slow execution of the inner loop.

There are several things that a team can do to optimize the inner loop for larger codebases:

* Only build and test what was changed.
* Cache intermediate build results to speed up to complete builds.
* Break up the codebase into small units and share binaries.

### Understand tangled loops

**Tangled loops** refer to the complications that arise when separating a monolithic codebase into different packages. While this approach can initially work well, issues can arise when developing new features that require extensive framework updates.

![Cool picture](Pictures/outer-loop-09b3065e.png)

Coevolving code in separate repositories can lead to friction and force the inner loop to include the outer loop of the separated framework code. This results in added "tax" like code reviews, scanning passes, and release pipelines. Developers often resort to local hacks to move forward efficiently, but these can become messy and the outer loop tax must still be paid eventually. Breaking up code into separate packages can work well if done carefully.

![Cool picture](Pictures/tangled-loops-02684f79.png)

### Introduction to continuous monitoring

**Continuous monitoring** refers to the process and technology required to incorporate monitoring across each phase of your DevOps and IT operations lifecycles. It helps to continuously ensure your application's health, performance, reliability, and infrastructure as it moves from development to production.

![Cool picture](Pictures/route-system-feedback-b3040309.png)

**Azure Monitor** is the unified monitoring solution in Azure that provides full-stack observability across applications and infrastructure in the cloud and on-premises. It works seamlessly with Visual Studio and Visual Studio Code during development and testing and integrates with Azure DevOps for release management and work item management during deployment and operations. It even integrates across your *ITSM* and *SIEM* tools to help track issues and incidents within your existing IT processes.

To be continued...
